# lec5 SPOC思考题NOTICE- 有"w3l1"标记的题是助教要提交到学堂在线上的。- 有"w3l1"和"spoc"标记的题是要求拿清华学分的同学要在实体课上完成，并按时提交到学生对应的git repo上。- 有"hard"标记的题有一定难度，鼓励实现。- 有"easy"标记的题很容易实现，鼓励实现。- 有"midd"标记的题是一般水平，鼓励实现。## 个人思考题---请简要分析最优匹配，最差匹配，最先匹配，buddy systemm分配算法的优势和劣势，并尝试提出一种更有效的连续内存分配算法 (w3l1)```  + 采分点：说明四种算法的优点和缺点  - 答案没有涉及如下3点；（0分）  - 正确描述了二种分配算法的优势和劣势（1分）  - 正确描述了四种分配算法的优势和劣势（2分）  - 除上述两点外，进一步描述了一种更有效的分配算法（3分） ``````最先匹配：优势在于实现简单，且会再搞地址空间有大块的空闲空间；缺点在于外部碎片较多，且分配大块时速度较慢。最佳匹配：优势在于大部分分配尺寸较小时，效果很好，可避免大的空闲分区被拆分，可减小外部碎片的大小，相对简单。缺点在于，有大量外部碎片，释放分区较慢，容易产生很多无用的小碎片。最差匹配：中等大小的分配较多时，效果最好。避免出现太多的小碎片。缺点在于释放分区较慢，有外部碎片。容易破坏大的空闲分区，因此后续难以分配的分区。伙伴系统：优势，安全性高，效率高。劣势，在若存在大量的略比2^U大的内存分配请求。更加有效的分配方法是：根据具体情况选择相应的分配方法，比如当空闲内存多的时候，采用优先匹配，当碎片较多的时候，采用最佳匹配。当存在非常大块的内存块时，采用最差匹配。这样一来，各种匹配方法的优点都利用起来了。```- [x]  >  ## 小组思考题请参考ucore lab2代码，采用`struct pmm_manager` 根据你的`学号 mod 4`的结果值，选择四种（0:最优匹配，1:最差匹配，2:最先匹配，3:buddy systemm）分配算法中的一种或多种，在应用程序层面(可以 用python,ruby,C++，C，LISP等高语言)来实现，给出你的设思路，并给出测试用例。 (spoc)优先算法，java语言。MemoryManage类，是各种匹配方式的父类。```package testjava;public class MemoryManage {			protected char memory[];	protected int memorySize;		protected MemoryManage(int _size) {		memorySize = _size;		memory = new char[_size];	}		protected void request() {			}		protected void release() {			}}```FirstMemoryManage类，用于主要功能实现，request相当于malloc，release相当于free，为了简单起见，变量名作为参数，且为char型。基本思路就是维护freeMemoryBlockList和usedMemoryBlockList两个list。release后需要merge。其实由于利用的是linked list，部分寻址可能略低效，不过我已经尽量注意了。。```package testjava;import java.util.LinkedList;import java.util.List;public class FirstMemoryManage extends MemoryManage{		List<FreeMemoryBlock> freeMemoryBlockList = new LinkedList<FreeMemoryBlock>();	List<UsedMemoryBlock> usedMemoryBlockList = new LinkedList<UsedMemoryBlock>();	FirstMemoryManage(int _size) {		super(_size);		freeMemoryBlockList.add(new FreeMemoryBlock(0, _size));	}		void request(char name, int size) {		int index = 0;				if (freeMemoryBlockList.size() <= 0)			return;				for (FreeMemoryBlock fmb : freeMemoryBlockList) {			if (fmb.size > size) {				usedMemoryBlockList.add(new UsedMemoryBlock(name, fmb.begin, size));				fmb.begin = fmb.begin+size;				fmb.size = fmb.size - size;				break;			} else if (fmb.size == size){				usedMemoryBlockList.add(new UsedMemoryBlock(name, fmb.begin, size));				freeMemoryBlockList.remove(index);				break;			}			index ++;		}	}		void release(char name) {		int index_u = 0;		for (UsedMemoryBlock umb : usedMemoryBlockList) {			if (umb.name == name) {				int index_f = 0;				for (FreeMemoryBlock fmb : freeMemoryBlockList) {					if (fmb.begin > umb.begin) {						freeMemoryBlockList.add(index_f, new FreeMemoryBlock(umb.begin, umb.size));						mergeFreeBlock(index_f);						usedMemoryBlockList.remove(index_u);						break;					}					index_f ++;				}				break;			}			index_u ++;		}	}		void mergeFreeBlock(int index) {		if (index+1 < freeMemoryBlockList.size() && 				freeMemoryBlockList.get(index+1).begin == 				freeMemoryBlockList.get(index).begin + freeMemoryBlockList.get(index).size) {			freeMemoryBlockList.get(index).size = freeMemoryBlockList.get(index).size + freeMemoryBlockList.get(index+1).size;			freeMemoryBlockList.remove(index+1);			mergeFreeBlock(index);		} else if (index-1 >= 0 && 				freeMemoryBlockList.get(index).begin == 				freeMemoryBlockList.get(index-1).begin + freeMemoryBlockList.get(index-1).size) {			freeMemoryBlockList.get(index-1).size = freeMemoryBlockList.get(index-1).size + freeMemoryBlockList.get(index).size;			freeMemoryBlockList.remove(index);			mergeFreeBlock(index-1);		}		}		void print() {		for (UsedMemoryBlock umb : usedMemoryBlockList) {			System.out.print(umb);		}		for (FreeMemoryBlock fmb : freeMemoryBlockList) {			System.out.print(fmb);		}	}		static public void main(String args[]) {		FirstMemoryManage mmu = new FirstMemoryManage(1024);		mmu.request('a', 63);mmu.print();System.out.println();		mmu.request('b', 37);mmu.print();System.out.println();		mmu.request('c', 99);mmu.print();System.out.println();		mmu.request('e', 2);mmu.print();System.out.println();		mmu.release('b');mmu.print();System.out.println();		mmu.release('e');mmu.print();System.out.println();		mmu.request('f',22);mmu.print();System.out.println();		mmu.release('a');mmu.print();System.out.println();		mmu.release('f');mmu.print();System.out.println();		mmu.release('c');mmu.print();System.out.println();	}}```FreeMemoryBlock，空闲段```package testjava;public class FreeMemoryBlock {		public int begin;	public int size;	FreeMemoryBlock(int _begin, int _size) {		begin = _begin;		size = _size;	}		public String toString() {		return "begin: " + begin + " size: " + size + "\n";	}}```已被使用的段```package testjava;public class UsedMemoryBlock {		public int begin;	public int size;	public char name;		UsedMemoryBlock(char _name, int _begin, int _size) {		name = _name;		begin = _begin;		size = _size;	}		public String toString() {		return "name: " + name + " begin: " + begin + " size: " + size + "\n";	}}```测试部分在FirstMemoryManage的main里完成，测试内容```		mmu.request('a', 63);		mmu.request('b', 37);		mmu.request('c', 99);		mmu.request('e', 2);		mmu.release('b');		mmu.release('e');		mmu.request('f',22);		mmu.release('a');		mmu.release('f');		mmu.release('c');```测试结果```name: a begin: 0 size: 63begin: 63 size: 961name: a begin: 0 size: 63name: b begin: 63 size: 37begin: 100 size: 924name: a begin: 0 size: 63name: b begin: 63 size: 37name: c begin: 100 size: 99begin: 199 size: 825name: a begin: 0 size: 63name: b begin: 63 size: 37name: c begin: 100 size: 99name: e begin: 199 size: 2begin: 201 size: 823name: a begin: 0 size: 63name: c begin: 100 size: 99name: e begin: 199 size: 2begin: 63 size: 37begin: 201 size: 823name: a begin: 0 size: 63name: c begin: 100 size: 99begin: 63 size: 37begin: 199 size: 825name: a begin: 0 size: 63name: c begin: 100 size: 99name: f begin: 63 size: 22begin: 85 size: 15begin: 199 size: 825name: c begin: 100 size: 99name: f begin: 63 size: 22begin: 0 size: 63begin: 85 size: 15begin: 199 size: 825name: c begin: 100 size: 99begin: 0 size: 100begin: 199 size: 825begin: 0 size: 1024``````如何表示空闲块？ 如何表示空闲块列表？ [(start0, size0),(start1,size1)...]在一次malloc后，如果根据某种顺序查找符合malloc要求的空闲块？如何把一个空闲块改变成另外一个空闲块，或消除这个空闲块？如何更新空闲块列表？在一次free后，如何把已使用块转变成空闲块，并按照某种顺序（起始地址，块大小）插入到空闲块列表中？考虑需要合并相邻空闲块，形成更大的空闲块？如果考虑地址对齐（比如按照4字节对齐），应该如何设计？如果考虑空闲/使用块列表组织中有部分元数据，比如表示链接信息，如何给malloc返回有效可用的空闲块地址而不破坏元数据信息？伙伴分配器的一个极简实现http://coolshell.cn/tag/buddy```四字节对齐其实不麻烦，分配的时候的begin强制要求模4余0，再稍加修改即可，不过好像是纯体力活就没做了...merge的过程在代码里有，大概就是先后看，再前看即可，本人用递归实现。— ## 扩展思考题阅读[slab分配算法](http://en.wikipedia.org/wiki/Slab_allocation)，尝试在应用程序中实现slab分配算法，给出设计方案和测试用例。## “连续内存分配”与视频相关的课堂练习### 5.1 计算机体系结构和内存层次MMU的工作机理？- [x]  >  http://en.wikipedia.org/wiki/Memory_management_unitL1和L2高速缓存有什么区别？- [x]  >  http://superuser.com/questions/196143/where-exactly-l1-l2-and-l3-caches-located-in-computer>  Where exactly L1, L2 and L3 Caches located in computer?>  http://en.wikipedia.org/wiki/CPU_cache>  CPU cache### 5.2 地址空间和地址生成编译、链接和加载的过程了解？- [x]  >  动态链接如何使用？- [x]  >  ### 5.3 连续内存分配什么是内碎片、外碎片？- [x]  >  为什么最先匹配会越用越慢？- [x]  >  为什么最差匹配会的外碎片少？- [x]  >  在几种算法中分区释放后的合并处理如何做？- [x]  >  ### 5.4 碎片整理一个处于等待状态的进程被对换到外存（对换等待状态）后，等待事件出现了。操作系统需要如何响应？- [x]  >  ### 5.5 伙伴系统伙伴系统的空闲块如何组织？- [x]  >  伙伴系统的内存分配流程？- [x]  >  伙伴系统的内存回收流程？- [x]  >  struct list_entry是如何把数据元素组织成链表的？- [x]  >  